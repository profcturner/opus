#!/bin/sh -e

# Source debconf library.
. /usr/share/debconf/confmodule

# summary of how this script can be called:
#        * <postinst> `configure' <most-recently-configured-version>
#        * <old-postinst> `abort-upgrade' <new version>
#        * <conflictor's-postinst> `abort-remove' `in-favour' <package>
#          <new-version>
#        * <postinst> `abort-remove'
#        * <deconfigured's-postinst> `abort-deconfigure' `in-favour'
#          <failed-install-package> <version> `removing'
#          <conflicting-package> <version>
# for details, see http://www.debian.org/doc/debian-policy/ or
# the debian-policy package

case "$1" in
    configure)
    ;;

    abort-upgrade|abort-remove|abort-deconfigure)
    ;;

    *)
        echo "postinst called with unknown argument \`$1'" >&2
        exit 1
    ;;
esac

# The main event

if [ "$1" = "configure" ]
then
  echo "Writing debconf configuration ..."
  # Remove any existing debconf config
  if [ -e /etc/opus/debconf_config.php ]
  then
    rm /etc/opus/debconf_config.php
  fi
  # Write the debconf recorded values to config.php insert
  touch /etc/opus/debconf_config.php
  echo "<?php"  >>  /etc/opus/debconf_config.php
  echo "// DO NOT EDIT THIS FILE, it is automatically generated from debconf"  >> /etc/opus/debconf_config.php
  echo "// Use dpkg-reconfigure -p low opus to regenerate this file" >> /etc/opus/debconf_config.php
  db_get opus/fq_hostname
  echo "\$conf['webhost'] = '$RET';" >> /etc/opus/debconf_config.php
  db_get opus/institution
  echo "\$conf['institution'] = '$RET';" >> /etc/opus/debconf_config.php
  echo "\$conf['database'] = array();" >> /etc/opus/debconf_config.php
  db_get opus/db_hostname
  data_hostname=$RET
  echo "\$conf['database']['hostname'] = '$RET';" >>  /etc/opus/debconf_config.php
  db_get opus/db_database
  data_database=$RET
  echo "\$conf['database']['database'] = '$RET';" >>  /etc/opus/debconf_config.php
  db_get opus/db_username
  data_username=$RET
  echo "\$conf['database']['username'] = '$RET';" >>  /etc/opus/debconf_config.php
  db_get opus/db_password
  data_password=$RET
  echo "\$conf['database']['password'] = '$RET';" >>  /etc/opus/debconf_config.php
  echo "?>" >>  /etc/opus/debconf_config.php
  chown www-data:root /etc/opus/*.php
  chmod 640 /etc/opus/*.php

  # Do we have the root password for MySQL?
  db_get opus/have_root_password
  have_password=$RET
  
  if [ "$have_password" = "yes" ]
  then
    # get the root password
    db_get opus/root_db_password
    root_db_password=$RET
  fi

  # It is hard to be idempotent and fully effective here. We have to rely on the
  # supplied database not clashing with an existing one, since we can't easily
  # tell if the existing database is there from a previous install (or on a
  # totally different server).
  
  echo "creating the MySQL database ..."
  
  if [ "$have_password" = "yes" ]
    then
    set +e
    # try a trivial query, logging in as MySQL root
    command_result=`echo "SELECT VERSION()" | mysql -h $data_hostname -u root --password=$root_db_password 2>&1`
    if [ "$?" -ne 0 ]
    then
      # We don't have valid root credentials
      have_password="no"
      # Warn the user it's all gone fubar
      db_input high opus/invalid_root_password || true
      db_go
    fi
  fi
  
  # Ok, let's try to go on
  if [ "$have_password" = "yes" ]
  then
    # It went ok! Try some more... Back to strict error checking.
    # We want to know if these bomb out
    set -e
    # Create the actual database
    echo "CREATE DATABASE IF NOT EXISTS $data_database" | mysql -h $data_hostname -u root --password=$root_db_password
    # Ensure permissions are set up
    echo "GRANT ALL ON $data_database.* TO $data_username@$data_hostname IDENTIFIED BY '$data_password' " | mysql -h $data_hostname -u root --password=$root_db_password
    # Now, try using the user just created to import schema
    echo "Installing initial schema ..."
    gzip -d -c /usr/share/doc/opus/sql_patch/schema.sql.gz | mysql -h $data_hostname -u $data_username --password=$data_password $data_database
  else
    # All we can do is use the non-root credentials for the schema import
    set -e
    echo "Installing initial schema ..."
    gzip -d -c /usr/share/doc/opus/sql_patch/schema.sql.gz | mysql -h $data_hostname -u $data_username --password=$data_password $data_database
  fi

  # OK, schema should be installed, check if any data exists, again
  num_users=`echo "select count(username) from id" | mysql --skip-column-names -h $data_hostname -u $data_username --password=$data_password $data_database`
  if [ $num_users -eq 0 ]
  then
    # No installed users, better import some data
    echo "Installing initial data ..."
    gzip -d -c /usr/share/doc/opus/sql_patch/data.sql.gz | mysql -h $data_hostname -u $data_username --password=$data_password $data_database
    # Set the email address from debconf data
    db_get opus/proot_email
    proot_email=$RET
    if [ $proot_email != "" ]
    then
      echo "update admins set email='$RET' where user_id=1" | mysql -h $data_hostname -u $data_username --password=$data_password $data_database
    fi
  fi
  
  # TODO: We need to write the code (for new versions) to sequentially apply
  # SQL patches from the sql_patch directory. This is moot for now since this is the
  # first external launch

  # Remove any root password
  db_reset opus/root_db_password

  # set permissions on other dirs
  echo "Creating paths and setting permissions ..."
  chown www-data:root /usr/share/opus/photos
  chown www-data:root /usr/share/opus/resources
  chown www-data:root /usr/share/opus/templates_*
  chmod 770 /usr/share/opus/photos
  chmod 770 /usr/share/opus/resources
  chmod 770 /usr/share/opus/templates_*
fi

# Install a symlink from the config file to the /etc directory
if [ "$1" = "configure" ] && [ ! -e /usr/share/opus/include/config.php ]
then
  echo "Installing initial OPUS configuration..."
  ln -s /etc/opus/config.php /usr/share/opus/include/config.php
fi

# Ensure log file stubs are present, have the right ownership and permissions
if [ "$1" = "configure" ]
then
  chown www-data:root /var/log/opus
  chmod 770 /var/log/opus
  if [ ! -e /var/log/opus/access.log ]; then touch /var/log/opus/access.log; chown www-data:root /var/log/opus/access.log; chmod 660 /var/log/opus/access.log; fi
  if [ ! -e /var/log/opus/cron.log ]; then touch /var/log/opus/cron.log; chown www-data:root /var/log/opus/cron.log; chmod 660 /var/log/opus/cron.log; fi
  if [ ! -e /var/log/opus/security.log ]; then touch /var/log/opus/security.log; chown www-data:root /var/log/opus/security.log; chmod 660 /var/log/opus/security.log; fi
  if [ ! -e /var/log/opus/admin.log ]; then touch /var/log/opus/admin.log; chown www-data:root /var/log/opus/admin.log; chmod 660 /var/log/opus/admin.log; fi
  if [ ! -e /var/log/opus/debug.log ]; then touch /var/log/opus/debug.log; chown www-data:root /var/log/opus/debug.log; chmod 660 /var/log/opus/debug.log; fi
fi

# Install the apache2 configuration if required
if [ "$1" = "configure" ] && [ -e /etc/apache2/ ] && [ ! -e /etc/apache2/conf.d/opus.conf ]
then
  echo "Installing OPUS apache2 configuration..."
  ln -s /etc/opus/apache2.conf /etc/apache2/conf.d/opus.conf
  apache2ctl restart
fi


# At some point, we might need to check for a few pear modules (mail ones)

# Now for debhelper deep magic
# dh_installdeb will replace this with shell code automatically
# generated by other debhelper scripts.

#DEBHELPER#

exit 0
